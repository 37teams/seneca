---
layout: main
title: Getting Started
---

<% section_link = (title,code) => %>
<div class="section-link">
<a name="<%- code %>"></a>
<a href="#<%- code %>">&nbsp;&nbsp;&sect;&nbsp;&nbsp;</a>
</div>

### <%= title %>
<% end %>


# <%= @document.title %>

Seneca lets you build a microservice system without worrying about how
things will fit together in production. You don't need to know where
the other services are located, how many of them there are, or what
they do. Everything external to your business logic, such as
databases, caches, or third party integrations can likewise be hidden
behind microservices.

This decoupling makes your system easy to build and change on a
continuous basis. It works because Seneca has two core features.

   * **Transport Independence:** you can send messages between services in many ways, all hidden from your business logic.
   * **Pattern Matching:** instead of fragile service discovery, you just let the world know what sort of messages you care about.

Messages are JSON documents, with any internal structure you
like. Messages can be sent via HTTP/S, TCP connections, message
queues, publish/subscribe services or any mechanism that moves bits
around. From your perspective as the writer of a service, you just
send messages out into the world. You don't want to know which
services get them &mdash; that creates fragile coupling.

Then there are the messages you'd like to receive. You specify the
property patterns that you care about, and Seneca (with a little
configuration help) makes sure that you get any messages matching
those patterns, sent by other services. The patterns are very simple,
just a list of key-value pairs that the top level properties of the
JSON message document must match.

This _Getting Started_ guide will cover Seneca in a broad way, but
won't go into too much depth. The [Next Steps](#next-steps) section at
the end of this Page is your starting point for more details.


<%= section_link 'A Simple Microservice', 'simple-microservice' %> 

Let's start with some code. Here's a service that sums two numbers:

``` js
var seneca = require('seneca')()

seneca.add( 
  {role:'math', cmd:'sum'}, 
  function( msg, respond ) {
    var sum = msg.left + msg.right
    respond( null, { answer: sum } )
  })
```

To call this service, you write:

``` js
seneca.act( 
  {role:'math', cmd:'sum', left:1, right:2}, 
  function( err, result ) {
    if( err ) return console.error( err )
    console.log( result )
  })
```

For the moment this is all happening in the same process, and there's
no network traffic. In-process function calls are a type of message
transport too!

The example code to try this out is in
[sum.js](https://github.com/senecajs/getting-started/blob/master/sum.js). To
run the code, follow these steps:

   1. Open a terminal, and `cd` to your projects folder
   2. Run `git clone https://github.com/senecajs/getting-started`
   3. Run `npm install` to install the dependent modules, including Seneca
   3. Run `node sum.js`

This guide assumes you already have [Node.js](http://nodejs.org) installed.

When you run `sum.js`, you get the following output:

``` bash
2015-07-02T12:38:08.788Z	xi94dnm0nrky/1435840688779/64029/-	INFO	hello	Seneca/0.6.2/xi94dnm0nrky/1435840688779/64029/-	
{ answer: 3 }
```

The first line is logging information that Seneca prints to let you
know that it has started. The second line is the result produced after
the message has been matched and processed.

The `seneca.add` method adds a new _action_ pattern to the Seneca
instance. This pattern is matched against any JSON messages that the
Seneca instance receives. The action is a function that is executed
when a pattern matches a message.

The `seneca.add` method has two parameters:

  * `pattern`: the property pattern to match in messages,
  * `action`: the function to execute if a message matches.

The action function has two parameters:

   * `msg`: the matching inbound message (provided as a plain object),
   * `respond`: a callback function that you use to provide a respond to the message.

The respond function is a callback with the standard `error, result`
signature. Let's put this all together again:

<div class="src-anno">
<br>
&larr; pattern to match<br>
&larr; action function<br>
&larr; the real work, adding two numbers<br>
&larr; provide a result object; there's no error</br>
</div>

``` js
seneca.add( 
  {role:'math', cmd:'sum'}, 
  function( msg, respond ) {
    var sum = msg.left + msg.right
    respond( null, { answer: sum } )
  })
```

In the example code, the action computes the sum of two numbers,
provided via the `left` and `right` properties of the message
object. Not all messages generate a result, but as this is the most
common case, Seneca allows you to provide the result via a callback
function.

In summary, the action pattern `role:math,cmd:sum` acts on the message

``` js
{ "role": "math", "cmd": "sum", left:1, right:2 }
```

to produce the result:

``` js
{ "answer": 3 }
```

There is nothing special about the properties `role` and `cmd`. They
just happen to be the ones you are using for pattern matching.

The `seneca.act` method submits a message to act on. It takes two parameters:

   * `msg`: the message object,
   * `response_callback`: a function that receives the message response, if any.

The response callback is a function you provide with the standard
`error, result` signature. If there was a problem (say, the message
matched no patterns), then the first argument will be an
[Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
object. If everything went to plan, the second argument will be the
result object. In the example code, these arguments are simply printed
to the console:


<div class="src-anno" style="margin-left: 20px">
<br>
&larr; submitted message<br>
&larr; response callback function<br>
&larr; [early return on error](http://thenodeway.io/posts/understanding-error-first-callbacks/)<br>
&larr; print result to console</br>
</div>

``` js
seneca.act( 
  {role:'math', cmd:'sum', left:1, right:2}, 
  function( err, result ) {
    if( err ) return console.error( err )
    console.log( result )
  })
```

The example code in the
[sum.js](https://github.com/senecajs/getting-started/blob/master/sum.js)
file shows you how to define and call an action pattern inside the
same Node.js process. Soon you'll see how to split this code over
multiple processes.


<%= section_link 'How Patterns Work', 'how-patterns-work' %>


Using patterns instead of network addresses or topics makes it much
easier to extend and enhance your system over time by adding new
microservices incrementally. Let's extend our system with the ability
to multiply two numbers.

We want messages that look like this:

``` js
{ "role": "math", "cmd": "product", left:3, right:4 }
```

to produce results like this:

``` js
{ "answer": 12 }
```

You can use the `role:math,cmd:sum` action pattern as a template to
define a new `role:math,cmd:product` action:

``` js
seneca.add( 
  {role:'math', cmd:'product'}, 
  function( msg, respond ) {
    var product = msg.left * msg.right
    respond( null, { answer: product } )
  })
```

And you can call it in exactly the same way:

``` js
seneca.act( 
  {role:'math', cmd:'product', left:3, right:4}, 
  console.log
)
```

Here, you use `console.log` as a shortcut to print out both the error
(if any), and the result. Running this code produces:

``` bash
null { answer: 12 }
```

Putting this all together, you get:

``` js
var seneca = require('seneca')()

seneca.add( 
  {role:'math', cmd:'sum'}, 
  function( msg, respond ) {
    var sum = msg.left + msg.right
    respond( null, { answer: sum } )
  })

seneca.add( 
  {role:'math', cmd:'product'}, 
  function( msg, respond ) {
    var product = msg.left * msg.right
    respond( null, { answer: product } )
  })


seneca
  .act( 
    {role:'math', cmd:'sum', left:1, right:2}, 
    console.log
  )
  .act( 
    {role:'math', cmd:'product', left:3, right:4}, 
    console.log
  )
```

In this example the `seneca.act` calls are chained together. Seneca
provides a chaining API as a convenience. Chained calls are executed
in order, but *not* in series, so their results could come back in any
order.

This code is available in the
[sum-product.js](https://github.com/senecajs/getting-started/blob/master/sum-product.js)
file.


<%= section_link 'Extending Functionality with Patterns', 'extend-with-patterns' %>


Patterns make it easy to extend your functionality. Instead of adding
`if` statements and complex logic, you add more patterns. Lets extend
the addition action with the ability to force integer-only
arithmetic. To do this, you can add a new property, `integer:true` to
the message object. Then you provide a new action for messages that
have this property:

``` js
seneca.add( 
  {role:'math', cmd:'sum', integer:true}, 
  function( msg, respond ) {
    var sum = Math.floor(msg.left) + Math.floor(msg.right)
    respond( null, { answer: sum } )
  })
```

Now, the message:

``` js
{ "role": "math", "cmd": "sum", left:1.5, right:2.5, integer:true }
```

will produce the result:

``` js
{ "answer": 3 }  // == 1 + 2, as decimals removed
```

What happens if you add both patterns to the same system? How does
Seneca choose which one to use? The more specific pattern always
wins. That is, the pattern with the most matching attributes is the
one that has precedence.

Here's some code to show this:

``` js
var seneca = require('seneca')()

seneca
  .add( 
    {role:'math', cmd:'sum'}, 
    function( msg, respond ) {
      var sum = msg.left + msg.right
      respond( null, { answer: sum } )
    })

  // both these messages will match role:math,cmd:sum

  .act( 
    {role:'math', cmd:'sum', left:1.5, right:2.5}, 
    console.log // prints { answer: 4 }
  )
  .act( 
    // the extra integer property is just ignored!
    {role:'math', cmd:'sum', left:1.5, right:2.5, integer:true}, 
    console.log // prints { answer: 4 }
  )


  .add( 
    {role:'math', cmd:'sum', integer:true}, 
    function( msg, respond ) {
      var sum = Math.floor(msg.left) + Math.floor(msg.right)
      respond( null, { answer: sum } )
    })

  // this still matches role:math,cmd:sum
  .act( 
    {role:'math', cmd:'sum', left:1.5, right:2.5}, 
    console.log // prints { answer: 4 }
  )

  // BUT this matches role:math,cmd:sum,integer:true
  // because it's more specific - more properties match
  .act( 
    {role:'math', cmd:'sum', left:1.5, right:2.5, integer:true}, 
    console.log // prints { answer: 3 } !!!
  )
```

And the output it generates is:

``` bash
2015-07-02T15:34:06.094Z	69kfu5lr238x/1435851246084/64488/-	INFO	hello	Seneca/0.6.2/69kfu5lr238x/1435851246084/64488/-	
null { answer: 4 }
null { answer: 4 }
null { answer: 4 }
null { answer: 3 }
```

The first two `.act` calls both match the `role:math,cmd:sum` action
pattern. Then the integer-only action pattern
`role:math,cmd:sum,integer:true` is defined. After that, the third
call to `.act` gos with the `role:math,cmd:sum` action, but the fourth
goes with `role:math,cmd:sum,integer:true`. This code also
demonstrates that you can chain `.add` and `.act` calls together. This
code is available in the
[sum-integer.js](https://github.com/senecajs/getting-started/blob/master/sum-integer.js)
file.

The ability to easily extend the behaviour of your actions by matching
more specific kinds of messages is an easy way to handle new and
changing requirements while your project is in development and when
it is live and needs to adapt. It also has the advantage that you do
not need to modify existing code, which is always dangerous. It's much
safer to add new code to handle special cases. In a production system
you won't even need to do a re-deploy. Your existing services can stay
running as they are. All you need to do is start up your new service.


<%= section_link 'Code Re-use with Patterns', 'reuse-with-patterns' %>

Action patterns can call other action patterns to get their work
done. Let's modify our example code to use this approach.

``` js
var seneca = require('seneca')()

seneca
  .add( 
    'role:math,cmd:sum', 
    function( msg, respond ) {
      var sum = msg.left + msg.right
      respond( null, { answer: sum } )
    })

  .add( 
    'role:math,cmd:sum,integer:true', 
    function( msg, respond ) {
      
      // reuse role:math,cmd:sum
      this.act({
        role:  'math', 
        cmd:   'sum',
        left:  Math.floor(msg.left),
        right: Math.floor(msg.right),
      }, respond)
    })

  // this matches role:math,cmd:sum
  .act( 'role:math,cmd:sum,left:1.5,right:2.5', 
        console.log // prints { answer: 4 }
      )

  // BUT this matches role:math,cmd:sum,integer:true
  .act( 'role:math,cmd:sum,left:1.5,right:2.5,integer:true', 
        console.log // prints { answer: 3 } !!!
      )
```

In this version, the definition of the
`role:math,cmd:sum,integer:true` action pattern uses the previously
defined `role:math,cmd:sum` action pattern, but first modifies the
message to convert the `left` and `right` properties into integers.

Inside the action function, the context variable, `this`, is a
reference to the current Seneca instance. This is the proper way to
reference Seneca inside actions, as you will get the full context of
the current action call. Among other things, this makes your logs more
informative.

This code uses an abbreviated form of JSON to specify the patterns and
messages. For example, the object literal form

``` js
{role:'math', cmd:'sum', left:1.5, right:2.5}
```

becomes:

``` js
role:math,cmd:sum,left:1.5,right:2.5
```

This format, [jsonic](https://github.com/rjrodger/jsonic), which you
provide as a string literal, is a convenience format to make patterns
and messages more concise in your code.

The code for the above example is available in the
[sum-reuse.js](https://github.com/senecajs/getting-started/blob/master/sum-reuse.js)
file.


<%= section_link 'Patterns are Unique, with Overrides', 'patterns-unique-override' %> 

  - uniqueness, priors, print tree

- plugins
  - define
  - logging
  - ref list of

- services
  - listen and client
  - pins

- web server integration
  - express

- data entities
  - standard patterns
  - simple active record
  - namespaces

- what next
  


<p>
Let's add another command:
</p>

<div class="highlight"><pre><code class="lang-js"
>seneca.add( {role:'math', cmd:'product'}, function(args,callback) {
  var product = args.left * args.right
  callback(null,{answer:product})
})

seneca.act( {role:'math', cmd:'product', left:3, right:4}, 
            function(err,result) {
              if( err ) return console.error( err )
              console.log(result)
            })
</code></pre></div>

<div class="highlight"><pre><code class="lang-bash"
>$ node example.js
{ answer: 3 }
{ answer: 12 }
</code></pre></div>

<p>
You can add new commands whenever you like, wherever you like. 
</p>


<p>This named argument style is fun, but if you want a real API, you can have that too:</p>

<div class="highlight"><pre><code class="lang-js"
>function print(err,result) {console.log(result)}

var math = seneca.pin({role:'math',cmd:'*'})
math.sum( {left:1,right:2}, print )
math.product( {left:1,right:2}, print )
</code></pre></div>


<p>
By <i>pinning</i> the pattern <code>{role:'math',cmd:'*'}</code> you created an object with methods that matched all the
<code>cmd</code> properties.
</p>

  <h3>Why use Seneca?</h3>

<p>
<i>Seneca</i> provides plugins - sets of commands - that look after the foundations of your app for you:
<ul>
  <li>Organize your business logic
  <li>Network API
  <li>Data layer
  <li>Caching
  <li>Logging
  <li>User management
  <li>Distributed processing
</ul>

You write your own plugins and commands using the same system. 
</p>

<p>
<i>Seneca</i> is not a web framework, it's a business logic organizer. You can use it with any web framework.
</p>

<p>
Here's an example of how this helps you. Let's say the <i>product</i>
command needs to live on a separate server. You can move it there with
<i>no changes to your calling code</i>. First, set up the server:
</p>

<div class="highlight"><pre><code class="lang-js"
>seneca.add({role:'math', cmd:'product'}, function(args,callback) {
  var product = args.left * args.right
  callback(null,{answer:product})
})

seneca.use('transport')

var connect = require('connect')
var app = connect()
  .use( connect.json() )
  .use( seneca.service() )
  .listen(10171)
</code></pre></div>

<p>
The <code>seneca.use</code> method loads in a plugin. In this case,
the <i>transport</i> plugin, which can accept commands over a HTTP
interface. <i>Seneca</i> exposes any plugin HTTP interface by
returning a middleware function from the
<code>seneca.service</code> method. You can use this directly with the 
<a href="http://www.senchalabs.org/connect">connect</a> or 
<a href="http://expressjs.com">express</a> modules.
</p>


<p>On the client side, just <i>transport</i> the remote patterns:</p>

<div class="highlight"><pre><code class="lang-js"
>seneca.use('transport',{
  pins:[ {role:'math',cmd:'product'} ]
})

seneca.act( {role:'math', cmd:'product', left:3, right:4}, 
            function(err,result) {
              if( err ) return console.error( err )
              console.log(result)
            })

</code></pre></div>

<p>
The <code>pins</code> option to the <i>transport</i> plugin accepts a
set of patterns that will be sent over to the server (running on
localhost by default).  The <i>transport</i> plugin just
calls <code>seneca.add</code> for each pin, and proxies the input and
output to the remote server.
</p>

<p>
Your calling code, the <code>seneca.act</code> call, <i>does not
change</i>. You now have a distributed system with no
refactoring. Fire up a few <i>math.product</i> servers, put them
behind a load balancer, and now you have a scalable system too.
</p>



  <h3>But what about data storage?</h3>

<p>
You really need a common database layer so that plugins and commands
can all deal with data in the same way. Let's go with
an <a href="http://en.wikipedia.org/wiki/Active_record_pattern">Active
Record</a> style - it's nice and easy. 
</p>

<div class="highlight"><pre><code class="lang-js"
>var product = seneca.make('product')
product.name = 'apple'
product.price = 100

product.save$(function( err, product ) {
  if( err ) return console.error( err )
  console.log( 'saved: '+product )

  // product.id was generated for you
  product.load$({id:product.id},function( err, product ) {
    if( err ) return console.error( err )
    console.log( 'loaded: '+product )
  })
})
</code></pre></div>

<p>
The <code>make</code> method creates an "Active Record"-ish object for
you. The properties of this object store your data.  Call
the <code>save$</code> and <code>load$</code> methods to save and load
your data from the database.  You also get the <code>list$</code>
method for queries, and <code>remove$</code> for deleting.
</p>

<p>
You get an in-memory data store automatically, so the above code works
out of the box without any database configuration. Here's how you would use MongoDB:
</p>

<div class="highlight"><pre><code class="lang-js"
>seneca.use( 'mongo-store', 
            {name:'mydata',host:'127.0.0.1',port:27017} )

seneca.ready( function(err,seneca){
  if( err ) return console.error( 'ERROR:'+err )

  var product = seneca.make('product')
  product.name = 'apple'
  product.price = 100

  product.save$(function( err, product ) {
    if( err ) return console.error( err )

    // product.id is a MongoDB id this time
    product.load$({id:product.id},function( err, product ) {
      if( err ) return console.error( err )
      console.log( 'loaded: '+product )
    })
  })
})
</code></pre></div>

<p>
The <code>seneca.use</code> method tells <i>Seneca</i> to load a
plugin, including any commands the plugin exposes. In this case,
you're loading the <i>mongo-store</i> plugin, which lets you talk to
the MongoDB database.
</p>

<p>
To use the <i>mongo-store</i> plugin, you'll need to install it:

<div class="highlight"><pre><code class="lang-bash"
>npm install seneca-mongo-store
</code></pre></div>
</p>

<p>
The <code>seneca.ready</code> method waits for the database connection
to be established. Apart from plugin configuration, your data logic
code is <i>exactly the same</i>. Swapping databases at any stage of your project is trivial.
</p>

<p>
How is the database layer implemented? It's just another set of commands. Here's the same code again:
</p>

<div class="highlight"><pre><code class="lang-js"
>var product = seneca.make('product')
product.name = 'apple'
product.price = 100

seneca.act( 
  { role:'entity', cmd:'save', ent:product},
  function( err, product ) {
    if( err ) return console.error( err )
    console.log( 'saved: '+product )

    seneca.act( 
      // q is: the query - find matching property values
      // qent is: entity type we want back
      { role:'entity', cmd:'load', q:{id:product.id}, qent:product},
      function( err, product ) {
        if( err ) return console.error( err )
        console.log( 'loaded: '+product )
      })
  })
</code></pre></div>

<p>
You can add support for your favorite database by writing a plugin with commands for
each of the entity operations: <code>save</code>, <code>load</code>,
etc. Here are some of the data stores <i>Seneca</i> supports:
<ul> 
  <li>Memory (transient) - built in
  <li>JSON files (on disk) - <a href="http://github.com/rjrodger/seneca-jsonfile-store">seneca-jsonfile-store</a>
  <li>JSON resources (REST API) - <a href="http://github.com/rjrodger/seneca-jsonrest-store">seneca-jsonrest-store</a>
  <li>MongoDB - <a href="http://github.com/rjrodger/seneca-mongo-store">seneca-mongo-store</a>
  <li>MySQL - <a href="https://github.com/mirceaalexandru/seneca-mysql-store">seneca-mysql-store</a>
  <li>PostgreSQL - <a href="https://github.com/marianr/seneca-postgres-store">seneca-postgres-store</a>
  <li>Redis - <a href="https://github.com/bamse16/seneca-redis-store">seneca-redis-store</a>
  <li>CouchDB - <a href="https://github.com/bamse16/seneca-couch-store">seneca-couch-store</a>
  <li>SQLite - <a href="https://github.com/bamse16/seneca-sqlite">seneca-sqlite-store</a>
</ul> 
</p>

<p>
You can even decide to save different entities into different
databases - for example, put user profiles into MongoDB, purchase
transactions into MySQL, and sessions into Redis.  You do need to stay
database independent by avoiding table joins, <a href="http://en.wikipedia.org/wiki/Denormalization">but
you don't need them anyway</a>!
</p>


<a name="next-steps"></a>
<h4>What Next?</h4>

For practical details, visit the <a href="http://github.com/rjrodger/seneca">Seneca github project page</a>.

<p>
The article <a href="https://blog.engineyard.com/2013/deploying-node-app">Deploying a Production Node.js App to Engine Yard</a> takes you step by step through the process of building a real application with Seneca.
</p>


