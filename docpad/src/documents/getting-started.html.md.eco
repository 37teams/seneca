---
layout: main
title: Getting Started
---

<% section_link = (title,code) => %>
<div class="section-link">
<a name="<%- code %>"></a>
<a href="#<%- code %>">&nbsp;&nbsp;&sect;&nbsp;&nbsp;</a>
</div>

### <%= title %>
<% end %>


# <%= @document.title %>

Seneca lets you build a microservice system without worrying about how
things will fit together in production. You don't need to know where
the other services are located, how many of them there are, or what
they do. Everything external to your business logic, such as
databases, caches, or third party integrations can likewise be hidden
behind microservices.

This decoupling makes your system easy to build and change on a
continuous basis. It works because Seneca has two core features.

   * **Transport Independence:** you can send messages between services in many ways, all hidden from your business logic.
   * **Pattern Matching:** instead of fragile service discovery, you just let the world know what sort of messages you care about.

Messages are JSON documents, with any internal structure you
like. Messages can be sent via HTTP/S, TCP connections, message
queues, publish/subscribe services or any mechanism that moves bits
around. From your perspective as the writer of a service, you just
send messages out into the world. You don't want to know which
services get them &mdash; that creates fragile coupling.

Then there are the messages you'd like to receive. You specify the
property patterns that you care about, and Seneca (with a little
configuration help) makes sure that you get any messages matching
those patterns, sent by other services. The patterns are very simple,
just a list of key-value pairs that the top level properties of the
JSON message document must match.

This _Getting Started_ guide will cover Seneca in a broad way, but
won't go into too much depth. The [Next Steps](#next-steps) section at
the end of this Page is your starting point for more details.


<%= section_link 'A Simple Microservice', 'simple-microservice' %> 

Let's start with some code. Here's a service that sums two numbers:

``` js
var seneca = require('seneca')()

seneca.add( 
  {role:'math', cmd:'sum'}, 
  function( msg, respond ) {
    var sum = msg.left + msg.right
    respond( null, { answer: sum } )
  })
```

To call this service, you write:

``` js
seneca.act( 
  {role:'math', cmd:'sum', left:1, right:2}, 
  function( err, result ) {
    if( err ) return console.error( err )
    console.log( result )
  })
```

For the moment this is all happening in the same process, and there's
no network traffic. In-process function calls are a type of message
transport too!

The example code to try this out is in
[sum.js](https://github.com/senecajs/getting-started/blob/master/sum.js). To
run the code, follow these steps:

   1. Open a terminal, and `cd` to your projects folder.
   2. Run `git clone https://github.com/senecajs/getting-started`.
   3. `cd` into the _getting-started_ folder.
   4. Run `npm install` to install the dependent modules, including Seneca.
   5. Run `node sum.js`.

This guide assumes you already have [Node.js](http://nodejs.org) installed.

When you run `sum.js`, you get the following output:

``` bash
2015-07-02T12:38:08.788Z	xi94dnm0nrky/1435840688779/64029/-	INFO	hello	Seneca/0.6.2/xi94dnm0nrky/1435840688779/64029/-	
{ answer: 3 }
```

The first line is logging information that Seneca prints to let you
know that it has started. The second line is the result produced after
the message has been matched and processed.

The `seneca.add` method adds a new _action_ pattern to the Seneca
instance. This pattern is matched against any JSON messages that the
Seneca instance receives. The action is a function that is executed
when a pattern matches a message.

The `seneca.add` method has two parameters:

  * `pattern`: the property pattern to match in messages,
  * `action`: the function to execute if a message matches.

The action function has two parameters:

   * `msg`: the matching inbound message (provided as a plain object),
   * `respond`: a callback function that you use to provide a respond to the message.

The respond function is a callback with the standard `error, result`
signature. Let's put this all together again:

<div class="src-anno">
<br>
&larr; pattern to match<br>
&larr; action function<br>
&larr; the real work, adding two numbers<br>
&larr; provide a result object; there's no error</br>
</div>

``` js
seneca.add( 
  {role:'math', cmd:'sum'}, 
  function( msg, respond ) {
    var sum = msg.left + msg.right
    respond( null, { answer: sum } )
  })
```

In the example code, the action computes the sum of two numbers,
provided via the `left` and `right` properties of the message
object. Not all messages generate a result, but as this is the most
common case, Seneca allows you to provide the result via a callback
function.

In summary, the action pattern `role:math,cmd:sum` acts on the message

``` js
{ "role": "math", "cmd": "sum", left:1, right:2 }
```

to produce the result:

``` js
{ "answer": 3 }
```

There is nothing special about the properties `role` and `cmd`. They
just happen to be the ones you are using for pattern matching.

The `seneca.act` method submits a message to act on. It takes two parameters:

   * `msg`: the message object,
   * `response_callback`: a function that receives the message response, if any.

The response callback is a function you provide with the standard
`error, result` signature. If there was a problem (say, the message
matched no patterns), then the first argument will be an
[Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
object. If everything went to plan, the second argument will be the
result object. In the example code, these arguments are simply printed
to the console:


<div class="src-anno" style="margin-left: 20px">
<br>
&larr; submitted message<br>
&larr; response callback function<br>
&larr; [early return on error](http://thenodeway.io/posts/understanding-error-first-callbacks/)<br>
&larr; print result to console</br>
</div>

``` js
seneca.act( 
  {role:'math', cmd:'sum', left:1, right:2}, 
  function( err, result ) {
    if( err ) return console.error( err )
    console.log( result )
  })
```

The example code in the
[sum.js](https://github.com/senecajs/getting-started/blob/master/sum.js)
file shows you how to define and call an action pattern inside the
same Node.js process. Soon you'll see how to split this code over
multiple processes.


<%= section_link 'How Patterns Work', 'how-patterns-work' %>


Using patterns instead of network addresses or topics makes it much
easier to extend and enhance your system over time by adding new
microservices incrementally. Let's extend our system with the ability
to multiply two numbers.

We want messages that look like this:

``` js
{ "role": "math", "cmd": "product", left:3, right:4 }
```

to produce results like this:

``` js
{ "answer": 12 }
```

You can use the `role:math,cmd:sum` action pattern as a template to
define a new `role:math,cmd:product` action:

``` js
seneca.add( 
  {role:'math', cmd:'product'}, 
  function( msg, respond ) {
    var product = msg.left * msg.right
    respond( null, { answer: product } )
  })
```

And you can call it in exactly the same way:

``` js
seneca.act( 
  {role:'math', cmd:'product', left:3, right:4}, 
  console.log
)
```

Here, you use `console.log` as a shortcut to print out both the error
(if any), and the result. Running this code produces:

``` bash
null { answer: 12 }
```

Putting this all together, you get:

``` js
var seneca = require('seneca')()

seneca.add( 
  {role:'math', cmd:'sum'}, 
  function( msg, respond ) {
    var sum = msg.left + msg.right
    respond( null, { answer: sum } )
  })

seneca.add( 
  {role:'math', cmd:'product'}, 
  function( msg, respond ) {
    var product = msg.left * msg.right
    respond( null, { answer: product } )
  })


seneca
  .act( 
    {role:'math', cmd:'sum', left:1, right:2}, 
    console.log
  )
  .act( 
    {role:'math', cmd:'product', left:3, right:4}, 
    console.log
  )
```

In this example the `seneca.act` calls are chained together. Seneca
provides a chaining API as a convenience. Chained calls are executed
in order, but *not* in series, so their results could come back in any
order.

This code is available in the
[sum-product.js](https://github.com/senecajs/getting-started/blob/master/sum-product.js)
file.


<%= section_link 'Extending Functionality with Patterns', 'extend-with-patterns' %>


Patterns make it easy to extend your functionality. Instead of adding
`if` statements and complex logic, you add more patterns. Lets extend
the addition action with the ability to force integer-only
arithmetic. To do this, you can add a new property, `integer:true` to
the message object. Then you provide a new action for messages that
have this property:

``` js
seneca.add( 
  {role:'math', cmd:'sum', integer:true}, 
  function( msg, respond ) {
    var sum = Math.floor(msg.left) + Math.floor(msg.right)
    respond( null, { answer: sum } )
  })
```

Now, the message:

``` js
{ "role": "math", "cmd": "sum", left:1.5, right:2.5, integer:true }
```

will produce the result:

``` js
{ "answer": 3 }  // == 1 + 2, as decimals removed
```

What happens if you add both patterns to the same system? How does
Seneca choose which one to use? The more specific pattern always
wins. That is, the pattern with the most matching attributes is the
one that has precedence.

Here's some code to show this:

``` js
var seneca = require('seneca')()

seneca
  .add( 
    {role:'math', cmd:'sum'}, 
    function( msg, respond ) {
      var sum = msg.left + msg.right
      respond( null, { answer: sum } )
    })

  // both these messages will match role:math,cmd:sum

  .act( 
    {role:'math', cmd:'sum', left:1.5, right:2.5}, 
    console.log // prints { answer: 4 }
  )
  .act( 
    // the extra integer property is just ignored!
    {role:'math', cmd:'sum', left:1.5, right:2.5, integer:true}, 
    console.log // prints { answer: 4 }
  )


  .add( 
    {role:'math', cmd:'sum', integer:true}, 
    function( msg, respond ) {
      var sum = Math.floor(msg.left) + Math.floor(msg.right)
      respond( null, { answer: sum } )
    })

  // this still matches role:math,cmd:sum
  .act( 
    {role:'math', cmd:'sum', left:1.5, right:2.5}, 
    console.log // prints { answer: 4 }
  )

  // BUT this matches role:math,cmd:sum,integer:true
  // because it's more specific - more properties match
  .act( 
    {role:'math', cmd:'sum', left:1.5, right:2.5, integer:true}, 
    console.log // prints { answer: 3 } !!!
  )
```

And the output it generates is:

``` bash
2015-07-02T15:34:06.094Z	69kfu5lr238x/1435851246084/64488/-	INFO	hello	Seneca/0.6.2/69kfu5lr238x/1435851246084/64488/-	
null { answer: 4 }
null { answer: 4 }
null { answer: 4 }
null { answer: 3 }
```

The first two `.act` calls both match the `role:math,cmd:sum` action
pattern. Then the integer-only action pattern
`role:math,cmd:sum,integer:true` is defined. After that, the third
call to `.act` gos with the `role:math,cmd:sum` action, but the fourth
goes with `role:math,cmd:sum,integer:true`. This code also
demonstrates that you can chain `.add` and `.act` calls together. This
code is available in the
[sum-integer.js](https://github.com/senecajs/getting-started/blob/master/sum-integer.js)
file.

The ability to easily extend the behaviour of your actions by matching
more specific kinds of messages is an easy way to handle new and
changing requirements while your project is in development and when
it is live and needs to adapt. It also has the advantage that you do
not need to modify existing code, which is always dangerous. It's much
safer to add new code to handle special cases. In a production system
you won't even need to do a re-deploy. Your existing services can stay
running as they are. All you need to do is start up your new service.


<%= section_link 'Code Re-use with Patterns', 'reuse-with-patterns' %>

Action patterns can call other action patterns to get their work
done. Let's modify our example code to use this approach.

``` js
var seneca = require('seneca')()

seneca
  .add( 
    'role:math,cmd:sum', 
    function( msg, respond ) {
      var sum = msg.left + msg.right
      respond( null, { answer: sum } )
    })

  .add( 
    'role:math,cmd:sum,integer:true', 
    function( msg, respond ) {
      
      // reuse role:math,cmd:sum
      this.act({
        role:  'math', 
        cmd:   'sum',
        left:  Math.floor(msg.left),
        right: Math.floor(msg.right),
      }, respond)
    })

  // this matches role:math,cmd:sum
  .act( 'role:math,cmd:sum,left:1.5,right:2.5', 
        console.log // prints { answer: 4 }
      )

  // BUT this matches role:math,cmd:sum,integer:true
  .act( 'role:math,cmd:sum,left:1.5,right:2.5,integer:true', 
        console.log // prints { answer: 3 } !!!
      )
```

In this version, the definition of the
`role:math,cmd:sum,integer:true` action pattern uses the previously
defined `role:math,cmd:sum` action pattern, but first modifies the
message to convert the `left` and `right` properties into integers.

Inside the action function, the context variable, `this`, is a
reference to the current Seneca instance. This is the proper way to
reference Seneca inside actions, as you will get the full context of
the current action call. Among other things, this makes your logs more
informative.

This code uses an abbreviated form of JSON to specify the patterns and
messages. For example, the object literal form

``` js
{role:'math', cmd:'sum', left:1.5, right:2.5}
```

becomes:

``` js
role:math,cmd:sum,left:1.5,right:2.5
```

This format, [jsonic](https://github.com/rjrodger/jsonic), which you
provide as a string literal, is a convenience format to make patterns
and messages more concise in your code.

The code for the above example is available in the
[sum-reuse.js](https://github.com/senecajs/getting-started/blob/master/sum-reuse.js)
file.


<%= section_link 'Patterns are Unique, with Overrides', 'patterns-unique-override' %> 

The action patterns that you define are unique. They can only trigger
one function. The patterns resolve using the rules:

   * more properties win, and
   * if the patterns have the same number of properties, they are matched in alphabetical order.

The reason that these rules are so simple is so that you can run them
"in your head". It's very easy to understand which pattern will
trigger which action function.

Here are some examples:

   * `a:1,b:2` wins over `a:1` as it has more properties.
   * `a:1,b:2` wins over `a:1,c:3` as `b` is before `c` alphabetically.
   * `a:1,b:2,d:4` wins over `a:1,c:3,d:4` as `b` is before `c` alphabetically.
   * `a:1,b:2,c:3` wins over `a:1,b:2` as it has more properties.
   * `a:1,b:2,c:3` wins over `a:1,c:3` as it has more properties.

To see this in action, run the file
[pattern-wins.js](https://github.com/senecajs/getting-started/blob/master/pattern-wins.js). For
more details, see the [patrun](https://www.npmjs.com/package/patrun)
module.

It is sometimes useful to have a way of enhancing the behaviour of an
action without rewriting it fully. For example, you might want to
perform custom validation of the message properties, or capture
message statistics, or add additional information to action results,
or throttle message flow rates.

In the example code, the addition action expects that the `left` and
`right` properties are finite numbers. Also, it's useful to include
the original input arguments in the output for debugging purposes. You
can add a validation check, and debugging information, using the
following code:

``` js
var seneca = require('seneca')()

seneca
  .add( 
    'role:math,cmd:sum', 
    function( msg, respond ) {
      var sum = msg.left + msg.right
      respond( null, { answer: sum } )
    })

  // override role:math,cmd:sum with additional functionality
  .add( 
    'role:math,cmd:sum', 
    function( msg, respond ) {
      
      // bail out early if there's a problem
      if( !Number.isFinite( msg.left ) ||
          !Number.isFinite( msg.right ) ) 
      {
        return respond( new Error("Expected left and right to be numbers.") )
      }

      // call previous action function for role:math,cmd:sum
      this.prior({
        role:  'math', 
        cmd:   'sum',
        left:  msg.left,
        right: msg.right,

      }, function( err, result ) {
        if( err ) return respond( err )

        result.info = msg.left+'+'+msg.right
        respond( null, result )
      })
    })

  // enhanced role:math,cmd:sum
  .act( 'role:math,cmd:sum,left:1.5,right:2.5', 
        console.log // prints { answer: 4, info: '1.5+2.5' }
      )
```

The Seneca instance provided to an action function via the the `this`
context variable has a special `prior` method that calls the previous
action definition for the current action pattern. The prior function has parameters:

   * `msg`: the msg object, which you may have modified
   * `response_callback`: a callback function, where you may modify the result

The example code shows you how to modify both the inbound message, and
the outbound result. Modification of either is optional &mdash; you
may leave the data unchanged and use this mechanism for enhanced
logging or auditing.

The example code also shows good practices for error handling. It uses
early returns to exit from the action function as soon as
possible. This avoids spurious indentation from `if-else`
statements. The error is provided using an `Error` object. This
ensures stack trace capture and proper handling.

Errors should only be used for invalid input or internal failures. For
example, if you are executing a database query that returns no data,
that is *not* an error, just a fact about the database. If the
database connection fails, that is an error.

The code for this example is in the
[sum-valid.js](https://github.com/senecajs/getting-started/blob/master/sum-valid.js)
file.


<%= section_link 'Organising Patterns into Plugins', 'organize-plugins' %> 

A Seneca instance is ultimately just a set of action patterns. You can
organize them by using namespacing conventions in your patterns, such as
`role:math`. To help with logging and debugging, Seneca supports a
minimalist notion of a plugin to help organize patterns.

A Seneca plugin is just a set of action patterns. The plugin can have
a name, which is used to annotate logging entries. Plugins can be
given a set of options to control their behaviour. Plugins also
provide a mechanism for executing initialisation functions in the
correct order. For example, you want your database connection to be
established before you try to read data from the database.

A Seneca plugin is a function that has a single parameter
`options`. You pass this plugin definition function to the
`seneca.use` method. Here is the minimal Seneca plugin (it does
nothing!).

``` js
function minimal_plugin( options ) { 
  console.log(options) 
}

require('seneca')()
  .use( minimal_plugin, {foo:'bar'} )
``` 

The `seneca.use` method takes two parameters:

   * `plugin`: plugin definition function, or plugin name,
   * `options`: options object for the plugin.

If you run the example code (in file
[minimal-plugin.js](https://github.com/senecajs/getting-started/blob/master/minimal-plugin.js)),
you'll get the following output:

``` bash
$ node minimal-plugin.js
2015-07-03T15:23:00.038Z	gh7s1570egff/1435936980028/65900/-	INFO	hello	Seneca/0.6.2/gh7s1570egff/1435936980028/65900/-	
{ foo: 'bar' }
```

Seneca provides detailed logging information when it starts, and also
when running. Normally, the log level is set to `INFO` which means you
don't see very much. To see all the logs, try:

``` bash
$ node minimal-plugin.js --seneca.log.all
... lots of log lines ...
```

You can narrow this down by
[grepping](http://www.cyberciti.biz/faq/howto-use-grep-command-in-linux-unix/)
the log output for log lines relevant to plugin definition.

``` bash
$ node minimal-plugin.js --seneca.log.all | grep plugin | grep DEFINE
2015...	3qf7...	DEBUG	plugin	basic           DEFINE	{}
2015...	3qf7...	DEBUG	plugin	transport       DEFINE	{}
2015...	3qf7...	DEBUG	plugin	web             DEFINE	{}
2015...	3qf7...	DEBUG	plugin	mem-store       DEFINE	{}
2015...	3qf7...	DEBUG	plugin	minimal_plugin  DEFINE	{foo=bar}
```

You can see that by default Seneca loads four built-in plugins:
[_basic_](https://www.npmjs.com/package/seneca-basic),
[_transport_](https://www.npmjs.com/package/seneca-transport),
[_web_](https://www.npmjs.com/package/seneca-web), and
[_mem-store_](https://www.npmjs.com/package/seneca-mem-store). These
provide core functionalities for basic microservices. You can also see
that your _minimal_plugin_ is in the list as well, and also shown are
the options you provided: `{foo=bar}`. The name _minimal_plugin_ is
obtained from the plugin definition function name, so you should
always give your plugin definition function a name.

Let's give the plugin some action patterns. The `this` context
variable of the plugin definition function is an instance of Seneca
that you can use to do this. Here's a _math_ plugin:

``` js
function math( options ) { 

  this.add( 'role:math,cmd:sum', function( msg, respond ) {
    respond( null, { answer: msg.left + msg.right } )
  })

  this.add( 'role:math,cmd:product', function( msg, respond ) {
    respond( null, { answer: msg.left * msg.right } )
  })

}

require('seneca')()
  .use( math )
  .act( 'role:math,cmd:sum,left:1,right:2', console.log )
```

Running this file
[math-plugin.js](https://github.com/senecajs/getting-started/blob/master/math-plugin.js) generates the output:

``` bash
$ node math-plugin.js
2015-07-03T15:43:13.067Z	xn5vquvubvjq/1435938193058/65962/-	INFO	hello	Seneca/0.6.2/xn5vquvubvjq/1435938193058/65962/-	
null { answer: 3 }
```

Let's look at the logging output relevant to this plugin by grepping for the string "math":

``` bash
$ node math-plugin.js --seneca.log.all | grep math
2015...	alqs...	DEBUG	delegate  {plugin$={name=math,tag=undefined},ungate$=true,fatal$=true}	29ny56	
2015...	alqs...	DEBUG	register  init     math	
2015...	alqs...	DEBUG	plugin    math     DEFINE	{}
2015...	alqs...	DEBUG	plugin    math     ADD	qlh13h47d0nu	cmd:sum,role:math	sum	
2015...	alqs...	DEBUG	plugin    math     ADD	10lk4seu3aee	cmd:product,role:math	product	
2015...	alqs...	DEBUG	plugin    math     options	set	{math={}}	
2015...	alqs...	DEBUG	act                -	-	DEFAULT	{init=math,tag=}	
2015...	alqs...	DEBUG	register  ready    math	{}
2015...	alqs...	DEBUG	register  install  math	{exports=[]}	
2015...	alqs...	DEBUG	act       math     -	IN	pg7er4ouia1p/u5hfgtpmkeoy	cmd:sum,role:math	{role=math,cmd=sum,left=1,right=2}	ENTRY	A;qlh13h47d0nu	-	
2015...	alqs...	DEBUG	act       math     -	OUT	pg7er4ouia1p/u5hfgtpmkeoy	cmd:sum,role:math	{answer=3}	EXIT	A;qlh13h47d0nu	5
```

There's detailed logging information on the plugin definition and
initialization, which you can mostly ignore for now. The most
interesting lines the ones showing the addition of action patterns
within the _math_ plugin, and then the execution of the
`role:math,cmd:sum,left:1,right:2` action, showing the inbound and
outbound messages.

``` bash
...
20.. al.. DEBUG plugin math   ADD ql.. cmd:sum,role:math     sum
20.. al.. DEBUG plugin math   ADD 10.. cmd:product,role:math product
...
20.. al.. DEBUG act    math - IN  pg.. cmd:sum,role:math {role=math,cmd=sum,left=1,right=2} ENTRY A;ql.. -	
20.. al.. DEBUG act    math - OUT pg.. cmd:sum,role:math {answer=3} EXIT A;ql.. 5
...
```

With Seneca, you build up your system by defining a set of patterns
that correspond to messages. You organize these patterns into plugins
to make logging and debugging easier. You then combine one or more
plugins into microservices. You'll create a _math_ microservice in the
next section.

Plugins often need to do some initialization work &mdash; such as
connecting to a database. You don't do this work in the body of the
plugin definition function. The definition function is synchronous by
design, because all it does is _define_ the plugin. In fact, you
should not call `seneca.act` at all in the plugin definition, just
`seneca.add`.

To initailize a plugin, you add a special action pattern:
`init:<plugin-name>`. This action pattern is called in
sequence for each plugin serially. The init function *must* call its
`respond` callback without errors. If plugin initialization fails,
then Seneca will exit the Node.js process. You want
your microservics to fail-fast (and scream loudly) when there's a
problem. All plugins must complete initialization before any actions
are executed.

To demonstrate initialization, let's add simplistic custom logging to
the _math_ plugin. When the plugin starts, it opens a log file, and
writes a log of all operations to the file. The file needs to open
successfully and be writable. If this fails, the microservice should
fail.

``` js
var fs = require('fs')

function math( options ) { 

  // the logging function, built by init
  var log

  // place all the patterns together
  // this make it easier to see them at a glance
  this.add( 'role:math,cmd:sum',     sum )
  this.add( 'role:math,cmd:product', product )

  // this is the special initialization pattern
  this.add( 'init:math', init )


  function init( msg, respond ) {
    // log to a custom file
    fs.open( options.logfile, 'a', function( err, fd ) {

      // cannot open for writing, so fail
      // this error is fatal to Seneca
      if( err ) return respond( err )

      log = make_log(fd)
      respond()
    })
  }

  function sum( msg, respond ) {
    var out = { answer: msg.left + msg.right }
    log( 'sum '+msg.left+'+'+msg.right+'='+out.answer+'\n' )
    respond( null, out )
  }

  function product( msg, respond ) {
    var out = { answer: msg.left * msg.right }
    log( 'product '+msg.left+'*'+msg.right+'='+out.answer+'\n' )
    respond( null, out )
  }


  function make_log( fd ) {
    return function( entry ) {
      fs.write( fd, new Date().toISOString()+' '+entry, null, 'utf8', function(err) {
        if( err ) return console.log( err )

        // ensure log entry is flushed
        fs.fsync( fd, function(err) {
          if( err ) return console.log( err )
        })
      }) 
    }
  }
}

require('seneca')()
  .use( math, {logfile:'./math.log'} )
  .act( 'role:math,cmd:sum,left:1,right:2', console.log )
```

In this plugin code, the patterns are organized at the top of the
plugin so that they are easy to see. The action functions are defined
below these. You can also see how the options are used to provide the
location for the custom log file (it should go without saying that
this is not a way to do production logging!).

The initialization function _init_ does some asynchronous file
system work, and so must complete before any actions can be
performed. If it fails, the whole service will fail to initialize. To
see this in action, try changing the log file location to something
invalid, like say `'/math.log'`.

This code is available in the
[math-plugin-init.js](https://github.com/senecajs/getting-started/blob/master/math-plugin-init.js)
file.


<%= section_link 'Writing Microservices', 'writing-microservices' %> 


- services
  - listen and client
  - debug info, tree, list, etc
  - pins

- web server integration
  - express

- data entities
  - standard patterns
  - simple active record
  - namespaces

- what next
  


<p>
Let's add another command:
</p>

<div class="highlight"><pre><code class="lang-js"
>seneca.add( {role:'math', cmd:'product'}, function(args,callback) {
  var product = args.left * args.right
  callback(null,{answer:product})
})

seneca.act( {role:'math', cmd:'product', left:3, right:4}, 
            function(err,result) {
              if( err ) return console.error( err )
              console.log(result)
            })
</code></pre></div>

<div class="highlight"><pre><code class="lang-bash"
>$ node example.js
{ answer: 3 }
{ answer: 12 }
</code></pre></div>

<p>
You can add new commands whenever you like, wherever you like. 
</p>


<p>This named argument style is fun, but if you want a real API, you can have that too:</p>

<div class="highlight"><pre><code class="lang-js"
>function print(err,result) {console.log(result)}

var math = seneca.pin({role:'math',cmd:'*'})
math.sum( {left:1,right:2}, print )
math.product( {left:1,right:2}, print )
</code></pre></div>


<p>
By <i>pinning</i> the pattern <code>{role:'math',cmd:'*'}</code> you created an object with methods that matched all the
<code>cmd</code> properties.
</p>

  <h3>Why use Seneca?</h3>

<p>
<i>Seneca</i> provides plugins - sets of commands - that look after the foundations of your app for you:
<ul>
  <li>Organize your business logic
  <li>Network API
  <li>Data layer
  <li>Caching
  <li>Logging
  <li>User management
  <li>Distributed processing
</ul>

You write your own plugins and commands using the same system. 
</p>

<p>
<i>Seneca</i> is not a web framework, it's a business logic organizer. You can use it with any web framework.
</p>

<p>
Here's an example of how this helps you. Let's say the <i>product</i>
command needs to live on a separate server. You can move it there with
<i>no changes to your calling code</i>. First, set up the server:
</p>

<div class="highlight"><pre><code class="lang-js"
>seneca.add({role:'math', cmd:'product'}, function(args,callback) {
  var product = args.left * args.right
  callback(null,{answer:product})
})

seneca.use('transport')

var connect = require('connect')
var app = connect()
  .use( connect.json() )
  .use( seneca.service() )
  .listen(10171)
</code></pre></div>

<p>
The <code>seneca.use</code> method loads in a plugin. In this case,
the <i>transport</i> plugin, which can accept commands over a HTTP
interface. <i>Seneca</i> exposes any plugin HTTP interface by
returning a middleware function from the
<code>seneca.service</code> method. You can use this directly with the 
<a href="http://www.senchalabs.org/connect">connect</a> or 
<a href="http://expressjs.com">express</a> modules.
</p>


<p>On the client side, just <i>transport</i> the remote patterns:</p>

<div class="highlight"><pre><code class="lang-js"
>seneca.use('transport',{
  pins:[ {role:'math',cmd:'product'} ]
})

seneca.act( {role:'math', cmd:'product', left:3, right:4}, 
            function(err,result) {
              if( err ) return console.error( err )
              console.log(result)
            })

</code></pre></div>

<p>
The <code>pins</code> option to the <i>transport</i> plugin accepts a
set of patterns that will be sent over to the server (running on
localhost by default).  The <i>transport</i> plugin just
calls <code>seneca.add</code> for each pin, and proxies the input and
output to the remote server.
</p>

<p>
Your calling code, the <code>seneca.act</code> call, <i>does not
change</i>. You now have a distributed system with no
refactoring. Fire up a few <i>math.product</i> servers, put them
behind a load balancer, and now you have a scalable system too.
</p>



  <h3>But what about data storage?</h3>

<p>
You really need a common database layer so that plugins and commands
can all deal with data in the same way. Let's go with
an <a href="http://en.wikipedia.org/wiki/Active_record_pattern">Active
Record</a> style - it's nice and easy. 
</p>

<div class="highlight"><pre><code class="lang-js"
>var product = seneca.make('product')
product.name = 'apple'
product.price = 100

product.save$(function( err, product ) {
  if( err ) return console.error( err )
  console.log( 'saved: '+product )

  // product.id was generated for you
  product.load$({id:product.id},function( err, product ) {
    if( err ) return console.error( err )
    console.log( 'loaded: '+product )
  })
})
</code></pre></div>

<p>
The <code>make</code> method creates an "Active Record"-ish object for
you. The properties of this object store your data.  Call
the <code>save$</code> and <code>load$</code> methods to save and load
your data from the database.  You also get the <code>list$</code>
method for queries, and <code>remove$</code> for deleting.
</p>

<p>
You get an in-memory data store automatically, so the above code works
out of the box without any database configuration. Here's how you would use MongoDB:
</p>

<div class="highlight"><pre><code class="lang-js"
>seneca.use( 'mongo-store', 
            {name:'mydata',host:'127.0.0.1',port:27017} )

seneca.ready( function(err,seneca){
  if( err ) return console.error( 'ERROR:'+err )

  var product = seneca.make('product')
  product.name = 'apple'
  product.price = 100

  product.save$(function( err, product ) {
    if( err ) return console.error( err )

    // product.id is a MongoDB id this time
    product.load$({id:product.id},function( err, product ) {
      if( err ) return console.error( err )
      console.log( 'loaded: '+product )
    })
  })
})
</code></pre></div>

<p>
The <code>seneca.use</code> method tells <i>Seneca</i> to load a
plugin, including any commands the plugin exposes. In this case,
you're loading the <i>mongo-store</i> plugin, which lets you talk to
the MongoDB database.
</p>

<p>
To use the <i>mongo-store</i> plugin, you'll need to install it:

<div class="highlight"><pre><code class="lang-bash"
>npm install seneca-mongo-store
</code></pre></div>
</p>

<p>
The <code>seneca.ready</code> method waits for the database connection
to be established. Apart from plugin configuration, your data logic
code is <i>exactly the same</i>. Swapping databases at any stage of your project is trivial.
</p>

<p>
How is the database layer implemented? It's just another set of commands. Here's the same code again:
</p>

<div class="highlight"><pre><code class="lang-js"
>var product = seneca.make('product')
product.name = 'apple'
product.price = 100

seneca.act( 
  { role:'entity', cmd:'save', ent:product},
  function( err, product ) {
    if( err ) return console.error( err )
    console.log( 'saved: '+product )

    seneca.act( 
      // q is: the query - find matching property values
      // qent is: entity type we want back
      { role:'entity', cmd:'load', q:{id:product.id}, qent:product},
      function( err, product ) {
        if( err ) return console.error( err )
        console.log( 'loaded: '+product )
      })
  })
</code></pre></div>

<p>
You can add support for your favorite database by writing a plugin with commands for
each of the entity operations: <code>save</code>, <code>load</code>,
etc. Here are some of the data stores <i>Seneca</i> supports:
<ul> 
  <li>Memory (transient) - built in
  <li>JSON files (on disk) - <a href="http://github.com/rjrodger/seneca-jsonfile-store">seneca-jsonfile-store</a>
  <li>JSON resources (REST API) - <a href="http://github.com/rjrodger/seneca-jsonrest-store">seneca-jsonrest-store</a>
  <li>MongoDB - <a href="http://github.com/rjrodger/seneca-mongo-store">seneca-mongo-store</a>
  <li>MySQL - <a href="https://github.com/mirceaalexandru/seneca-mysql-store">seneca-mysql-store</a>
  <li>PostgreSQL - <a href="https://github.com/marianr/seneca-postgres-store">seneca-postgres-store</a>
  <li>Redis - <a href="https://github.com/bamse16/seneca-redis-store">seneca-redis-store</a>
  <li>CouchDB - <a href="https://github.com/bamse16/seneca-couch-store">seneca-couch-store</a>
  <li>SQLite - <a href="https://github.com/bamse16/seneca-sqlite">seneca-sqlite-store</a>
</ul> 
</p>

<p>
You can even decide to save different entities into different
databases - for example, put user profiles into MongoDB, purchase
transactions into MySQL, and sessions into Redis.  You do need to stay
database independent by avoiding table joins, <a href="http://en.wikipedia.org/wiki/Denormalization">but
you don't need them anyway</a>!
</p>


<a name="next-steps"></a>
<h4>What Next?</h4>

For practical details, visit the <a href="http://github.com/rjrodger/seneca">Seneca github project page</a>.

<p>
The article <a href="https://blog.engineyard.com/2013/deploying-node-app">Deploying a Production Node.js App to Engine Yard</a> takes you step by step through the process of building a real application with Seneca.
</p>


